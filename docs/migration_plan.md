# План миграции AdamRMS с PHP-монолита на стек FastAPI + React + PostgreSQL

## 1. Подготовка репозитория и базовой инфраструктуры разработки
1.1 Создать тег или ветку `legacy/php-monolith` для фиксации исходного состояния проекта до начала миграции.
1.2 Перенести PHP-монолит в каталог `legacy/` и обновить относительные пути в Dockerfile и скриптах, чтобы исключить вмешательство в новую структуру.
1.3 Добавить каталоги `backend/`, `frontend/`, `infrastructure/`, `docs/` и сопутствующие `.gitkeep`, обеспечив чистое разделение артефактов.
1.4 Настроить `.gitignore` для Python, Node.js и инфраструктурных артефактов, чтобы избежать попадания сборочных файлов в репозиторий.
1.5 Обновить `Makefile` или создать новый, включив команды для сборки backend, frontend, прогонки тестов и миграций.
1.6 Добавить базовые CI-конфигурации (например, GitHub Actions) с задачами `lint` и `test` для backend и frontend, используя заглушечные команды.
1.7 Внедрить pre-commit конфигурацию с hook'ами форматирования для Python (ruff/black/isort) и TypeScript (eslint/prettier).
1.8 Создать шаблоны конфигурации окружения (`.env.example`) для backend и frontend с описанием обязательных переменных.
1.9 Подготовить скрипт инициализации локальной среды (например, `scripts/bootstrap_dev.sh`), запускающий docker-compose и выполняющий базовые проверки.
1.10 Обновить `README.md`, описав структуру каталогов, команды сборки и расположение legacy-кода.
1.11 Настроить автоматическую генерацию документации из backend (OpenAPI) и фронтенда (Storybook, при наличии) в каталог `docs/`.
1.12 Создать чек-лист перехода, фиксирующий готовность каждого каталога (код, тесты, конфигурация) перед началом активной миграции.

## 2. Инвентаризация функциональности PHP-монолита
2.1 Провести аудит каталога `src/` и классифицировать файлы на Twig-шаблоны, PHP-страницы, API-скрипты и утилиты.
2.2 Зафиксировать зависимости каждого модуля: подключаемые библиотеки, глобальные переменные, конфигурации, S3-бакеты.
2.3 Построить карту роутов (UI + API) с указанием URL, используемых HTTP-методов и ролей доступа.
2.4 Сохранить примеры входных/выходных данных для каждого API (форматы JSON, коды ошибок, правила пагинации).
2.5 Документировать бизнес-процессы и сценарии использования (например, создание актива, генерация счёта, смена инстанса).
2.6 Составить перечень Twig-компонентов, повторно используемых на разных страницах, и определить кандидатуры для React-компонент.
2.7 Зафиксировать все фоновые задачи и cron-скрипты, если они существуют, включая расписание и зависимости.
2.8 Оценить технический долг (устаревшие библиотеки, хардкод, отсутствующие тесты) и определить приоритеты устранения при переносе.
2.9 Сформировать backlog миграции, сгруппированный по предметным областям, с оценкой сложности и зависимостей.
2.10 Подготовить артефакты для тестирования: скриншоты интерфейсов, экспортированные данные, контрольные отчёты.
2.11 Зафиксировать метрики производительности legacy (время ответа ключевых страниц/API) для последующего сравнения.
2.12 Обозначить критичные риски (например, интеграции с внешними API) и предусмотреть временные стабилизационные меры.

## 3. Анализ данных и миграция MySQL → PostgreSQL
3.1 Извлечь актуальную схему из `db/schema.php` и Phinx-миграций, включая индексные и триггерные конструкции.
3.2 Построить ER-диаграмму с визуализацией связей, кардинальности и зависимостей между таблицами.
3.3 Согласовать целевую модель данных PostgreSQL, определив замену MySQL-типов (ENUM, SET, FIND_IN_SET) и кодировку UTF-8.
3.4 Сформировать SQLAlchemy-модели и Pydantic-схемы, соответствующие новой структуре, с учётом ограничений и дефолтов.
3.5 Настроить Alembic с разделением миграций на структуру и данные, определить naming conventions для constraint'ов.
3.6 Разработать ETL-пайплайн (dump → transform → load) на Python, обеспечивающий преобразование типов и валидацию ссылочной целостности.
3.7 Написать автоматические тесты, проверяющие корректность трансформаций и соответствие контрольным выборкам.
3.8 Настроить генерацию сидов/fixture для разработки и интеграционных тестов (Factory Boy/Faker), синхронизированную с Alembic.
3.9 Реализовать стратегию синхронизации данных во время параллельной эксплуатации (dual-write, CDC или регулярные дампы).
3.10 Подготовить план отката миграции и процедуры резервного копирования, включая проверку восстановления из backup.
3.11 Заменить скрипт `migrate.sh` и Phinx в Docker-сборке на Python-оркестрацию миграций и сидов.
3.12 Документировать процессы миграции, контрольные отчёты и чек-листы для окружений dev/stage/prod.

## 4. Развитие каркаса FastAPI
4.1 Расширить структуру `backend/app/` на каталоги `core/`, `api/routes/`, `models/`, `schemas/`, `services/`, `repositories/`, `auth/`, `integrations/`.
4.2 Внедрить Pydantic Settings для конфигураций окружения, включая секцию secrets и поддержку .env файлов.
4.3 Настроить единый логгер (structlog/loguru) с корреляционными ID, интеграцией с Sentry и форматами JSON.
4.4 Реализовать middleware для CORS, безопасности (rate limiting, headers), логирования запросов и измерения latency.
4.5 Ввести централизованные обработчики ошибок с маппингом бизнес-исключений на HTTP-коды и человекочитаемые сообщения.
4.6 Подключить зависимость для подключения к БД (SQLAlchemy + async engine), пул подключений и управление транзакциями.
4.7 Настроить поддержку фоновых задач (Celery + Redis или built-in BackgroundTasks) и heartbeat-механизмов.
4.8 Добавить генерацию OpenAPI-документации с тегами по доменам, примером запросов и схемами авторизации.
4.9 Ввести модуль тестовых фикстур (pytest) с разделением unit/integration и использованием TestClient/httpx.
4.10 Организовать pre-commit хуки (ruff, black, isort, mypy) и интегрировать их в CI.
4.11 Подготовить шаблон сервисного слоя (base classes) для ускорения последующего переноса доменных функций.
4.12 Обновить `backend/pyproject.toml`/`requirements.txt` с новыми зависимостями и зафиксировать версии.

## 5. Перенос доменной логики и API
5.1 Для каждой предметной области составить требования к FastAPI-маршрутам, включая параметры, фильтры и контракты ответов.
5.2 Реализовать репозитории, инкапсулирующие SQL-запросы и преобразование данных, с учётом особенностей PostgreSQL.
5.3 Написать сервисный слой, переносящий бизнес-правила из PHP (расчёт стоимостей, статусы, проверки прав доступа).
5.4 Создать Pydantic-схемы запросов/ответов с валидацией, форматированием валют и единиц измерения.
5.5 Перенести работу с файлами и генерацию подписанных URL в отдельные сервисы, используемые маршрутизаторами.
5.6 Реализовать механизмы аудита и логирования бизнес-событий с сохранением в БД и отправкой в аналитику.
5.7 Обеспечить обратную совместимость API: сохранить имена полей, обработку ошибок и коды ответов, используемые текущими клиентами.
5.8 Написать модульные и интеграционные тесты для каждого маршрута, проверяющие сценарии успеха и отказов.
5.9 Оптимизировать тяжёлые операции (пагинация, фильтрация) и использовать SQL-индексы, соответствующие новым запросам.
5.10 Задокументировать каждый API (описание, примеры, ограничения) и включить в общую OpenAPI-спецификацию.
5.11 Внедрить feature flags для переключения источника данных (PHP vs FastAPI) без перерыва в обслуживании.
5.12 Выполнить нагрузочное тестирование ключевых эндпоинтов и сравнить с базовыми показателями legacy.

## 6. Аутентификация, авторизация и аудит
6.1 Проанализировать поведение PHP-класса bID и связанных таблиц конфигурации/аудита.
6.2 Спроектировать модель данных для хранения пользователей, токенов, сессий, ролей и привязки к инстансам в PostgreSQL.
6.3 Реализовать модуль `backend/app/auth/` с поддержкой JWT, refresh-токенов, IP/UA-валидации и TTL-сессий.
6.4 Добавить middleware/Depends для проверки прав доступа, включая роли server/instance и кастомные пермишены.
6.5 Перенести механику «магических ссылок», восстановления доступа и «просмотра от лица клиента».
6.6 Настроить хранение аудита действий и конфигурационных изменений с сохранением формата legacy для аналитики.
6.7 Обеспечить совместимость с мобильными клиентами: версии API, заголовки, особые требования к токенам.
6.8 Реализовать защиту от brute force и rate limiting на уровне аутентификации.
6.9 Интегрировать модуль авторизации с фронтендом (OpenAPI, типы, SDK) и обеспечить единый источник прав.
6.10 Написать тесты на аутентификационный флоу, истечение токенов, отзыв сессий и аудиторские записи.
6.11 Задокументировать политики безопасности, требования к паролям, MFA (если вводится) и процессы управления учётными записями.
6.12 Организовать мониторинг и оповещения по событиям безопасности (неудачные логины, аномалии, подозрительные IP).

## 7. Интеграции и фоновые задачи
7.1 Каталогизировать все внешние интеграции из PHP (S3/CloudFront, email, аналитика, платежи) и определить целевые интерфейсы.
7.2 Создать модуль `backend/app/integrations/` с адаптерами для AWS (boto3), почтовых сервисов, уведомлений, аналитики.
7.3 Реализовать абстракции для подписанных ссылок, управления доступом к файлам и очистки устаревших объектов.
7.4 Настроить очередь фоновых задач (Celery/Redis) для отправки писем, обработки отчётов, генерации миниатюр.
7.5 Перенести cron-операции и задания из PHP в Celery beat или аналогичный планировщик.
7.6 Встроить наблюдаемость интеграций: метрики, логирование, алерты по ошибкам и таймаутам.
7.7 Разработать контрактные тесты для каждого адаптера с использованием sandbox-окружений провайдеров.
7.8 Обеспечить шифрование и безопасное хранение секретов (AWS, SMTP, аналитика) через Vault/Secrets Manager.
7.9 Согласовать стратегии отката и деградации (graceful fallback) при недоступности внешних сервисов.
7.10 Задокументировать процедуры подключения новых провайдеров и обновления credentials.
7.11 Обновить UI/UX фронтенда для работы с асинхронными операциями (индикаторы прогресса, retry, уведомления).
7.12 Провести нагрузочные и устойчивостные тесты фоновых задач, убедившись в масштабируемости новой архитектуры.

## 8. Реализация React + TypeScript SPA
8.1 Инициализировать проект (Vite/Next.js) с настройками TypeScript, ESLint, Prettier, Stylelint и Husky.
8.2 Определить архитектуру каталогов (`src/app`, `src/pages`, `src/widgets`, `src/features`, `src/shared`) и coding style.
8.3 Настроить систему роутинга (React Router/Next Router) и code-splitting для ленивой загрузки страниц.
8.4 Реализовать глобальный layout: навигация, выбор инстанса, уведомления, панель пользователя.
8.5 Настроить управление состоянием (React Query + Zustand/Redux Toolkit) с гидратацией из API и кешированием.
8.6 Создать модуль API-клиента с генерацией типов из OpenAPI (openapi-typescript-codegen) и обработкой ошибок.
8.7 Перенести общие UI-компоненты: таблицы, формы, модальные окна, фильтры, с учётом accessibility и интернационализации.
8.8 Спроектировать дизайн-систему (токены, темы, компоненты), адаптировать существующий бренд-гайд.
8.9 Реализовать загрузку файлов через подписанные URL, отображение прогресса и обработку ошибок.
8.10 Перенести страницы по приоритету: авторизация, dashboard, assets, projects, finance, maintenance, CMS.
8.11 Встроить механизмы локализации (i18next/FormatJS) и форматирование валют/единиц измерения.
8.12 Настроить Storybook (по необходимости) для документирования компонентов и визуальной регрессии.

## 9. Клиентская авторизация и работа с API
9.1 Разработать модуль аутентификации на фронтенде: хранение токенов (secure cookies/IndexedDB), refresh-flow, logout.
9.2 Интегрировать выбор инстанса и управление ролями, синхронизируя состояние с backend через защищённые эндпоинты.
9.3 Настроить перехватчики запросов (axios/fetch wrapper) для добавления заголовков, обработки 401/403 и повторных попыток.
9.4 Реализовать управление ошибками (toasts, inline errors) и централизованную обработку исключений.
9.5 Добавить поддержку offline/optimistic UI для критичных операций (например, обновление карточек assets).
9.6 Обеспечить совместимость с legacy API на переходный период через адаптеры/фичефлаги.
9.7 Настроить сбор метрик UX (Web Vitals, пользовательские события) и передачу в бекенд/аналитику.
9.8 Внедрить механизмы загрузки и кэширования справочников (reference data) с инвалидцией.
9.9 Реализовать клиентский аудит действий пользователя (журнал активностей, отслеживание изменений).
9.10 Написать unit-тесты (Jest/RTL) и e2e-тесты (Playwright) для ключевых сценариев авторизации и работы с API.
9.11 Документировать последовательность UI-флоу (авторизация, смена инстанса, загрузка файлов) с привязкой к маршрутам API.
9.12 Обеспечить доступность (WCAG) всех форм и процессов, связанных с авторизацией и управлением данными.

## 10. Тестирование и качество
10.1 Построить тестовую пирамиду: unit → integration → e2e → smoke, закрепив для каждого уровня инструменты и точки запуска в CI.
10.2 Внедрить статический анализ кода: ruff/black/mypy для backend, eslint/tsc/stylelint для frontend.
10.3 Настроить покрытие тестами (coverage.py, nyc) и пороги качества в CI.
10.4 Реализовать контрактные тесты между frontend и API на основе OpenAPI/JSON Schema.
10.5 Настроить визуальные регрессионные тесты (Storybook Chromatic/Playwright screenshots) для UI.
10.6 Ввести тестовые данные и фикстуры, синхронизированные с миграциями и обновляемые при изменении схемы.
10.7 Автоматизировать smoke-тесты окружений после деплоев и миграций.
10.8 Организовать тестирование производительности (Locust/k6) для ключевых эндпоинтов и пользовательских флоу.
10.9 Включить безопасность в тестовый контур: SAST/DAST, проверка зависимостей (Dependabot, pip-audit, npm audit).
10.10 Документировать процессы QA, чек-листы и критерии приёмки для каждой подсистемы.
10.11 Настроить отчётность по качеству (dashboards CI, алерты) и регулярные обзоры качества.
10.12 Подготовить автоматизированные отчёты по прогону тестов (JUnit XML, coverage) и интегрировать их в CI/CD для исторического анализа.

## 11. Инфраструктура и окружения
11.1 Создать Dockerfile для backend (uvicorn/gunicorn) и frontend (Node build + nginx) с оптимизированными слоями.
11.2 Обновить `docker-compose.yml`, добавив сервисы frontend, backend, PostgreSQL, Redis (для Celery), MinIO (для S3 sandbox), Traefik/nginx proxy.
11.3 Настроить .env-шаблоны для локальной разработки, stage и production, описав обязательные переменные и секреты.
11.4 Разработать Helm-чарты или Terraform-модули (если используется Kubernetes/Cloud) в каталоге `infrastructure/`.
11.5 Настроить CI/CD pipeline: линтинг → тесты → сборка контейнеров → прогон миграций → деплой → smoke-тесты.
11.6 Интегрировать управление секретами (Vault, AWS Secrets Manager) и обновление конфигураций без простоя.
11.7 Настроить логирование и мониторинг (Prometheus/Grafana, ELK/EFK, Sentry) с dashboards по ключевым метрикам.
11.8 Реализовать автоматическое масштабирование и health-checks для backend/frontend сервисов.
11.9 Организовать резервное копирование БД и артефактов, регламентировать частоту и процедуры восстановления.
11.10 Подготовить план аварийного восстановления (DRP) и сценарии переключения регионов/инстансов.
11.11 Документировать инфраструктурные процессы: обновление зависимостей, ротация сертификатов, обновление базовых образов.
11.12 Внедрить проверку безопасности контейнеров (Trivy, Grype) и политики доступа к репозиториям/окружениям.

## 12. Параллельная эксплуатация и вывод PHP
12.1 Определить стратегию поэтапного переключения трафика (reverse proxy rules, feature flags, shadow traffic).
12.2 Настроить проксирование запросов к новым FastAPI эндпоинтам по мере готовности, сохраняя обратную совместимость.
12.3 Синхронизировать данные между MySQL и PostgreSQL до окончательного переключения (replication/ETL расписание).
12.4 Ввести чек-листы отключения для каждой подсистемы: готовность API, фронта, миграции данных, тестов.
12.5 После переноса подсистемы проводить decommission PHP-страниц/API, документируя изменения и обновляя маршруты.
12.6 Настроить мониторинг отклонений в поведении (ошибки, время ответа, пользовательские метрики) во время A/B переключений.
12.7 Организовать канарейские релизы и механизм быстрого отката на PHP при критических сбоях.
12.8 Автоматизировать обновление правил маршрутизации и конфигураций прокси при переключении подсистем (шаблоны, проверки синтаксиса).
12.9 Провести финальную миграцию данных с остановкой записи в legacy, убедиться в консистентности и полноте.
12.10 После полной миграции удалить из репозитория PHP-код (`src/`, `db/`, `composer.*`, legacy Dockerfile) и архивировать в `legacy/`.
12.11 Обновить CI/CD, исключив legacy пайплайны и добавив проверки на отсутствие нового PHP-кода.
12.12 Зафиксировать технические результаты каждой фазы (изменённые маршруты, отключённые сервисы, найденные дефекты) в журнале миграции.

## 13. Документация и технические материалы
13.1 Обновить `README.md`, описав новый стек, инструкции по запуску backend/frontend, требования к окружению.
13.2 Создать разделы документации: архитектура, API, миграции данных, DevOps-процессы, эксплуатационные регламенты и чек-листы тестирования.
13.3 Сформировать developer handbook с best practices, код-стайлом, примерами использования сервисов и интеграций.
13.4 Подготовить технические спецификации интерфейсов: описание экранов, структур компонентов, состояний и маршрутов.
13.5 Документировать процессы CI/CD, инфраструктурные секреты, политики безопасности и доступов.
13.6 Настроить автоматическую генерацию API-документации из FastAPI (Swagger/ReDoc) и публикацию на портале разработчика.
13.7 Вести changelog миграции с описанием завершённых блоков и влияния на архитектуру системы.
13.8 Сформировать справочники по инструментам (React/TypeScript, FastAPI, Alembic, Celery) с указанием команд запуска и отладки.
13.9 Описать процедуры диагностики и устранения неисправностей (сбор логов, анализ метрик, перезапуск сервисов).
13.10 Ввести регламент обновления документации при каждом изменении функциональности или инфраструктуры.
13.11 Зафиксировать требования к версиям зависимостей и расписание их обновления с описанием процедуры тестирования.
13.12 Настроить автоматические проверки целостности документации (линтер Markdown, проверка ссылок, генерация диаграмм из исходников).

## 14. Финальная проверка и ретроспектива
14.1 Выполнить комплексное регрессионное тестирование UI и API после полного отключения PHP.
14.2 Провести нагрузочное тестирование и сравнить результаты с целевыми SLA, зафиксировав улучшения или отклонения.
14.3 Проверить целостность и полноту данных, используя SQL-скрипты сверки и контрольные отчёты.
14.4 Верифицировать корректность миграций Alembic на чистой базе и при обновлении существующей.
14.5 Подготовить отчёт по безопасности: результаты сканирования, выполнение политик, статус секретов.
14.6 Сформировать итоговый технический отчёт о миграции с описанием выполненных шагов, обнаруженных рисков и остаточных задач.
14.7 Проанализировать логи и метрики пострелизного периода, зафиксировать выявленные аномалии и способы их устранения.
14.8 Сформировать перечень технических улучшений пост-миграции (оптимизации, рефакторинг, автоматизация).
14.9 Актуализировать архитектурные диаграммы и описание потоков данных с учётом новой платформы.
14.10 Архивировать legacy-артефакты, обеспечить их доступ по запросу и прописать сроки хранения.
14.11 Настроить регулярные health-checkи и пострелизный мониторинг для раннего выявления проблем.
14.12 Документировать полученные уроки и рекомендации для будущих трансформаций архитектуры.
